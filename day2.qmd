---
title: "Geospatial data: Vector files and rasters"
subtitle: "Nairobi Workshop: Day 1 and 2"
author: 
  - name: Josh Merfeld
    affiliation: University of Queensland
  - name: David Newhouse
    affiliation: World Bank
date: "20 October 2025"

format: 
  revealjs:
    self-contained: true
    slide-number: false
    progress: false
    theme: custom.scss
    width: 1500
    height: 1500*(9/16)
    code-copy: true
    code-fold: show
    code-overflow: wrap
    highlight-style: github
execute:
  echo: true
  warnings: false
---


```{r}
#| label: setup
#| include: false
knitr::knit_hooks$set(crop = knitr::hook_pdfcrop)

library(tidyverse)
library(sf)
library(terra)
library(cowplot)
library(kableExtra)
library(tidyterra)

kdisgreen <- "#51247a"
accent <- "#962a8b"
accent2 <- "#2ea836"
kdisgray <- "#4085c6"

```



## Introduction to geospatial data

-   [One estimate](https://www.ibm.com/topics/geospatial-data) says that 100 TB of only weather data are generated every single day
    -   This means there is a lot of data to work with!
    -   Note that this is also problematic, since it can be difficult to work with such large datasets
-   Geospatial data is used in a variety of fields
    -   Agriculture
    -   Urban planning
    -   Environmental science
    -   Public health
    -   Transportation
    -   And many more!

## The amount of geospatial data is useful for many applications!

-   Geospatial data can be highly predictive of e.g. poverty
    -   Urbanity
    -   Land class/cover
    -   Vegetation indices
    -   Population counts
    -   etc. etc.
-   More importantly: it's available everywhere!




# Getting started with <br>geospatial data {#color-slide background-image="day2assets/titlebackground.jpg"}

```{css, echo=FALSE}
#color-slide, 
#color-slide h1 {
 color: white;
 text-align: left;
}
```

  
  
  
## Getting started with geospatial data

- What are we doing today?
  - Shapefiles
    - Polygons
    - Points
    - Lines
    - Mapping with the package `sf`
  - Coordinate reference systems
    - Latitude/longitude
    - Projections


  
  
  
## Shapefiles


- Shapefiles are a common format for geospatial data
  - They are a form of `vector` data

- Shapefiles are made up of _at least_ three files:
  - `.shp` - the shape itself
  - `.shx` - the index
  - `.dbf` - the attributes
  - `.prj` - the projection
    - This one is not technically necessary! But it's common to have.
  - What these all mean isn't important for now, just make sure they are there! Check the `day2files` folder on github.


  
  
  
## Let's look at Northern Malawi

::: columns
::: {.column width="50%"}

- Collection of `features`

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true
#| fig-width: 4

admin2 <- read_sf("day2files/mw2.shp")

ggplot() + 
  geom_sf(data = admin2, fill = "white", color = kdisgray) +
  geom_sf(data = admin2 |> filter(DIST_CODE=="107"), fill = "white", color = kdisgreen) +
  theme_bw() +
  labs(subtitle = "Districts in Northern Malawi") +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))

```


:::

::: {.column width="50%"}

- One `feature`

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true
#| fig-width: 6

ggplot() + 
  geom_sf(data = admin2 |> filter(DIST_CODE=="107"), fill = "white", color = kdisgreen) +
  theme_bw() +
  labs(subtitle = "Mzuzu City") +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
```

:::
:::




  
  
  
## Types of features


- `Polygons`
  - Areas
  - Districts, countries, etc.
- `Lines`
  - Lines
  - Roads, rivers, etc.
- `Points`
  - Points
  
  
  
## Let's start with polygons

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true
#| fig-width: 10

admin2 <- read_sf("day2files/mw2.shp")
vertices <- spatialEco::extract.vertices(admin2 |> filter(DIST_CODE=="107"))

g1 <- ggplot() + 
  geom_sf(data = admin2 |> filter(DIST_CODE=="107"), fill = "white", color = kdisgreen) +
  theme_bw() +
  labs(subtitle = "Mzuzu City") +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
g2 <- ggplot() + 
  geom_sf(data = admin2 |> filter(DIST_CODE=="107"), fill = "white", color = kdisgreen) +
  geom_sf(data = vertices, color = accent, size = 0.5) +
  theme_bw() +
  labs(subtitle = "Mzuzu City - 489 vertices!") +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))

plot_grid(g1, g2, ncol = 2) +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
```


  
  
  
## Imagine a rectangle, on a coordinate plane

```{r}
#| echo: false
#| include: true
#| fig-align: center

square <- data.frame(
  x = c(1, 1, 3, 3),
  y = c(1, 3, 3, 1)
)

ggplot() +
  geom_point(data = square, aes(x = x, y = y), color = NA) +
  scale_x_continuous(breaks = c(0, 1, 2, 3, 4), minor_breaks = NULL, limits = c(0, 4)) +
  scale_y_continuous(breaks = c(0, 1, 2, 3, 4), minor_breaks = NULL, limits = c(0, 4)) +
  theme_bw() +
  # add text
  annotate("text", x = 2, y = 2, label = "How many points do we need\nto create a rectangle on this\ncoordinate plane?") +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))


```


  
  
  
## Imagine a rectangle, on a coordinate plane

```{r}
#| echo: false
#| include: true
#| fig-align: center

square <- data.frame(
  x = c(1, 1, 3, 3),
  y = c(1, 3, 3, 1)
)

ggplot() +
  geom_point(data = square, aes(x = x, y = y), color = kdisgreen) +
  scale_x_continuous(breaks = c(0, 1, 2, 3, 4), minor_breaks = NULL, limits = c(0, 4)) +
  scale_y_continuous(breaks = c(0, 1, 2, 3, 4), minor_breaks = NULL, limits = c(0, 4)) +
  theme_bw() +
  # add text
  annotate("text", x = 2, y = 2, label = "Four points!") +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))


```


  
  
  
## Imagine a rectangle, on a coordinate plane

::: columns
::: {.column width="50%"}

- We need four points.
- But polygons in shapefiles are a little different.
  - We have to "close" the feature so it knows it's a polygon!
- We do this by adding a fifth point: the same as the first point!


```{=html}
<table style="width:100%">
  <caption><span data-qmd="Five points (vertices) in our feature"></span></caption>
  <thead>
    <tr style="border-top:1px solid black">
      <th><span data-qmd=" "></span></th>
      <th><span data-qmd="X value"></span></th>
      <th><span data-qmd="Y value"></span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Point 1</td>
      <td style='text-align:center; vertical-align:middle'> 1 </td>
      <td style='text-align:center; vertical-align:middle'> 1 </td>
    </tr>
    <tr>
      <td>Point 2</td>
      <td style='text-align:center; vertical-align:middle'> 3 </td>
      <td style='text-align:center; vertical-align:middle'> 1 </td>
    </tr>
    <tr>
      <td>Point 3</td>
      <td style='text-align:center; vertical-align:middle'> 3 </td>
      <td style='text-align:center; vertical-align:middle'> 3 </td>
    </tr>
    <tr>
      <td>Point 4</td>
      <td style='text-align:center; vertical-align:middle'> 1 </td>
      <td style='text-align:center; vertical-align:middle'> 3 </td>
    </tr>
    <tr>
      <td>Point 5</td>
      <td style='text-align:center; vertical-align:middle'> 1 </td>
      <td style='text-align:center; vertical-align:middle'> 1 </td>
    </tr>
  </tbody>
</table>
```


:::

::: {.column width="50%"}

```{r}
#| echo: false
#| include: true
#| fig-align: center

square <- data.frame(
  x = c(1, 1, 3, 3),
  y = c(1, 3, 3, 1)
)

ggplot() +
  geom_point(data = square, aes(x = x, y = y), color = kdisgreen) +
  scale_x_continuous(breaks = c(0, 1, 2, 3, 4), minor_breaks = NULL, limits = c(0, 4)) +
  scale_y_continuous(breaks = c(0, 1, 2, 3, 4), minor_breaks = NULL, limits = c(0, 4)) +
  theme_bw() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))


```

:::
:::





## All features are made of vertices

::: columns
::: {.column width="50%"}

- So we have all our vertices (489 of them!)
- The question:
  - What is the coordinate system here?

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| include: true
#| crop: true
#| fig-align: center
#| fig-width: 6

admin2 <- read_sf("day2files/mw2.shp")
vertices <- spatialEco::extract.vertices(admin2 |> filter(DIST_CODE=="107"))

ggplot() + 
  geom_sf(data = admin2 |> filter(DIST_CODE=="107"), fill = "white", color = kdisgreen) +
  geom_sf(data = vertices, color = accent, size = 0.5) +
  theme_bw() +
  labs(subtitle = "Mzuzu City - 489 vertices!") +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))

```

:::
:::





## All features are made of vertices

::: columns
::: {.column width="50%"}

- So we have all our vertices (489 of them!)
- The question:
  - What is the coordinate system here?
  
- We will return to this in a bit!

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| include: true
#| crop: true
#| fig-align: center
#| fig-width: 6

admin2 <- read_sf("day2files/mw2.shp")
vertices <- spatialEco::extract.vertices(admin2 |> filter(DIST_CODE=="107"))

ggplot() + 
  geom_sf(data = admin2 |> filter(DIST_CODE=="107"), fill = "white", color = kdisgreen) +
  geom_sf(data = vertices, color = accent, size = 0.5) +
  theme_bw() +
  labs(subtitle = "Mzuzu City - 489 vertices!") +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))

```

:::
:::







## One more example of polygons

::: columns
::: {.column width="50%"}

```{r}
#| echo: false
#| include: true
#| crop: true
#| fig-align: center
#| fig-width: 5

nyc <- read_sf("day2files/bldg_footprints.shp")

ggplot() + 
  geom_sf(data = nyc, fill = "white", color = kdisgreen) +
  theme_bw() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  # smaller axis labels
  theme(axis.text = element_text(size = 6))

```

:::

::: {.column width="50%"}



:::
:::







## One more example of polygons

::: columns
::: {.column width="50%"}

```{r}
#| echo: false
#| include: true
#| crop: true
#| fig-align: center
#| fig-width: 5

nyc <- read_sf("day2files/bldg_footprints.shp")

ggplot() + 
  geom_sf(data = nyc, fill = "white", color = kdisgreen) +
  theme_bw() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  # smaller axis labels
  theme(axis.text = element_text(size = 6))

```

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| include: true
#| crop: true
#| fig-align: center
#| fig-width: 5


ggplot() + 
  geom_sf(data = nyc, aes(fill = Height), color = NA) +
  scale_fill_distiller("Height (m)", palette = "Spectral") +
  theme_bw() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  # smaller axis labels
  theme(axis.text = element_text(size = 6)) +
  theme(legend.position = c(0.88, 0.14)) +
  # make legend smaller
  theme(legend.text = element_text(size = 8)) +
  theme(legend.title = element_text(size = 8)) +
  theme(legend.key.size = unit(0.4, "cm")) +
  # transparent legend background
  theme(legend.background = element_rect(fill = "transparent"))

```

:::
:::







## Lines

- Lines are also made up of vertices
- But they are not closed



## Lines example - "Primary" roads in India (2014)

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true

roads <- read_sf("day2files/indiaprimaryroads.shp")

ggplot() + 
  geom_sf(data = roads, color = kdisgreen) +
  theme_bw() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))

```



## One road

<br><br><br>
Length of this line feature: `r round(st_length(st_transform(roads[1,], 24378)), 2)` (m)

<br>

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true

vertices <- spatialEco::extract.vertices(roads[1,])

ggplot() + 
  geom_sf(data = roads[1,], color = kdisgreen) +
  geom_sf(data = vertices, color = accent, size = 2) +
  theme_bw() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))

```





## Points

- Points are exactly what they sound like: points!

- What could be a point?





## Points

- Points are exactly what they sound like: points!

- What could be a point?
  - A city
  - A weather station
  - A tree
  - A household
  - etc.





## What do you think this is?


::: columns
::: {.column width="50%"}

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true
#| fig-width: 5

points <- read_sf("day2files/hotosm_kor_railways_points_shp.shp")
korea <- read_sf("day2files/korea.shp")

ggplot() + 
  geom_sf(data = points, color = kdisgreen, size = 0.5) +
  geom_sf(data = korea, fill = NA, color = NA) +
  theme_bw() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  # smaller axis labels
  theme(axis.text = element_text(size = 6))
  

```

:::

::: {.column width="50%"}


:::
:::





## What do you think this is?


::: columns
::: {.column width="50%"}

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true
#| fig-width: 5

points <- read_sf("day2files/hotosm_kor_railways_points_shp.shp")
korea <- read_sf("day2files/korea.shp")

ggplot() + 
  geom_sf(data = points, color = kdisgreen, size = 0.5) +
  geom_sf(data = korea, fill = NA, color = NA) +
  theme_bw() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  # smaller axis labels
  theme(axis.text = element_text(size = 6))
  

```

:::

::: {.column width="50%"}

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true
#| fig-width: 5

ggplot() + 
  geom_sf(data = points, color = kdisgreen, size = 0.5) +
  geom_sf(data = korea, fill = NA, color = kdisgray) +
  theme_bw() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  # smaller axis labels
  theme(axis.text = element_text(size = 6))
  

```

:::
:::





## Train stations! First 15

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true
#| fig-width: 8

mat <- head(points |> select(name, name_en, railway, geometry) |> st_centroid(), 16)[-7,]
kable(mat, align = c("l", "l", "c", "c"), table.attr = "style='width:80%;'") |>
  kable_minimal()
  

```





## The train stations are a collection of features

- Just like before, the shapefile is a collection of features!
- The only difference now is that each feature is a point









# Reading and plotting shapefiles in R

```{r}
#| echo: false
#| include: true
#| crop: true
#| fig-height: 2
#| fig-align: left

gambia <- read_sf("day2files/gambia.shp")

ggplot() + 
  geom_sf(data = gambia, color = kdisgreen, fill = "#f0f1eb") +
  theme_bw() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  # smaller axis labels
  theme(axis.text = element_text(size = 6))
  

```



## Reading shapefiles in R

- My go-to package for shapefiles in R is `sf`
- Reading shapefiles is VERY easy! And you can treat them like dataframes.

```{r}
#| echo: true
#| include: true
#| fig-align: center
#| crop: true

library(sf)
# this is the shapefile for Gambia
gambia <- read_sf("day2files/gambia.shp")
gambia
```







## Plotting is also very easy


```{r}
#| echo: true
#| include: true
#| crop: true
#| fig-align: center

ggplot() + 
  geom_sf(data = gambia)
```








## My go-to theme


```{r}
#| echo: true
#| include: true
#| crop: true
#| fig-align: center
ggplot() +
  geom_sf(data = gambia) +
  theme_bw()
```







## Other changes you can make


```{r}
#| echo: true
#| include: true
#| crop: true
#| fig-align: center
ggplot() +
  geom_sf(data = gambia, fill = "#f0f1eb", color = "#006334") +
  theme_bw() +
  labs(subtitle = "Admin3s in Gambia")
```







## Give it a try with TAs (admin3) in Malawi (mw3.shp)

```{r}
#| eval: false
#| echo: true
#| code-fold: true
library(sf)
# this is the shapefile for the northern region of Malawi, TA level
northmw <- read_sf("day2files/mw3.shp")
ggplot() +
  geom_sf(data = northmw)
```

```{r}
#| eval: false
#| echo: true
#| code-fold: true

ggplot() +
  geom_sf(data = northmw) +
  theme_bw() +
  labs(subtitle = "TAs in Northern Malawi")
```






## One more example - map from earlier


::: columns
::: {.column width="65%"}

```{r}
#| echo: true
#| eval: false
#| crop: true
#| fig-align: center

admin2 <- read_sf("day2files/mw2.shp")

ggplot() + 
  geom_sf(data = admin2, 
    fill = "white", color = kdisgray) +
  geom_sf(data = admin2 |> filter(DIST_CODE=="107"), 
    fill = "white", color = kdisgreen) +
  theme_bw() +
  labs(subtitle = "Districts in Northern Malawi")
```

:::

::: {.column width="35%"}

![](day2assets/exampleplot.png){fig-align="center"}

:::
:::







## What if we want to plot mw2, mw3, and mw4?


```{r}
#| echo: false
#| eval: true
#| crop: true
#| fig-align: center

admin2 <- read_sf("day2files/mw2.shp")
admin3 <- read_sf("day2files/mw3.shp")
admin4 <- read_sf("day2files/mw4.shp")

g1 <- ggplot() + 
  geom_sf(data = admin2, fill = "white", color = "black") +
  theme_bw() + labs(subtitle = "A. Admin2 (districts)")
g2 <- ggplot() + 
  geom_sf(data = admin3, fill = "white", color = "black") +
  theme_bw() + labs(subtitle = "B. Admin3 (TAs)")
g3 <- ggplot() + 
  geom_sf(data = admin4, fill = "white", color = "black") +
  theme_bw() + labs(subtitle = "C. Admin4 (EAs)")

plot_grid(g1, g2, g3, ncol = 3)
```







## What if we want to plot mw2, mw3, and mw4?

```{r}
#| echo: true
#| eval: false
#| crop: true
#| fig-align: center

admin2 <- read_sf("day2files/mw2.shp")
admin3 <- read_sf("day2files/mw3.shp")
admin4 <- read_sf("day2files/mw4.shp")

g1 <- ggplot() + 
  geom_sf(data = admin2, fill = "white", color = "black") +
  theme_bw() + labs(subtitle = "A. Admin2 (districts)")
g2 <- ggplot() + 
  geom_sf(data = admin3, fill = "white", color = "black") +
  theme_bw() + labs(subtitle = "B. Admin3 (TAs)")
g3 <- ggplot() + 
  geom_sf(data = admin4, fill = "white", color = "black") +
  theme_bw() + labs(subtitle = "C. Admin4 (EAs)")
```







## What if we want to plot mw2, mw3, and mw4?

- Enter `cowplot`!

```{r}
#| echo: true
#| eval: false
#| crop: true
#| fig-align: center

library(cowplot)

plot_grid(g1, g2, g3, ncol = 3)
```




## A quick note about shapefile sizes

- What do you think is the main determinant of the size of a shapefile?

. . .

- The number of vertices!
  - Geographic size doesn't really matter!

. . .

- For the three Malawi shapefiles?
  - `mw2.shp`: 448 KB
  - `mw3.shp`: 4.9 MB
  - `mw4.shp`: 40.3 MB

. . .

- And this is only for Northern Malawi.
  - The entire country is 123 MB
  - The 2023 shapefile from OSM for Indian roads is 236 MB
  - The shapefile of Indian villages is 614 MB




## And that's only shapefile

- Other geospatial data can get even bigger!

- How large do you think the folder on my computer that contains imagery for all of Malawi (at 5m resolution) is?

. . .

- About 55 GB!

- This is just a warning... 







# Let's talk about coordinates




## Latitude and longitude on a globe

- The most common `coordinate reference system (CRS)` is latitude/longitude
  - Latitude: North/South
  - Longitude: East/West
  - The equator is at 0° latitude
  - The prime meridian is at 0° longitude<br><br>
  
- But there's a problem with using latitude/longitude
  - The Earth is a sphere (well, more or less; really an oblate spheroid)





## {background-image="day2assets/worldmap.png"}


## {background-image="day2assets/worldmap2.png"}





## The basic problem

- The basic problem is that one degree of longitude changes at different latitudes!
  - At the equator, one degree of longitude is about 111 km
  - At 15N/S, one degree of longitude is about 107 km
  - At 30N/S, one degree of longitude is about 96 km
  - At 45N/S, one degree of longitude is about 79 km
  - At 60N/S, one degree of longitude is about 56 km
    - This explains Greenland!<br><br>
    
- It's not an easy problem to solve, as all solutions have drawbacks!





## Preserve shape, give up area

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true

temp <- magick::image_read("day2assets/crs1.png")
temp2 <- magick::image_read("day2assets/crs2.png")


g1 <- magick::image_ggplot(temp) +
  labs(subtitle = "A. Mercator projection") +
  theme_void() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
g2 <- magick::image_ggplot(temp2) +
  labs(subtitle = "B. Lambert projection") +
  theme_void() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))

plot_grid(g1, NA, g2, ncol = 3, rel_widths = c(1, 0.05, 1)) +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))

```






## Projections

- A `projection` is a way to represent the Earth's surface on a flat plane
  - In other words, it's a way to transform the three-dimensional surface of the earth into two dimensions
  - Think of this as a way to "flatten" the Earth

. . .
  
- "Equal area" projections
  - These projections preserve the area of features
- "Conformal" projections
  - These projections preserve the shape of features

. . .
  
- It is impossible to perfectly preserve both!
  - But they can be close, especially in smaller areas
  - The earth looks quite flat from close up, after all
  
  
  
  
## Robinson projection: compromise across the board

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true

temp <- magick::image_read("day2assets/robinson.png")

magick::image_ggplot(temp) +
  theme_void() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  labs(caption = "Source: QGIS")
  

```
  
  
  
  
## Meractor projection: preserves angular relationships

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true

temp <- magick::image_read("day2assets/mercator.png")

magick::image_ggplot(temp) +
  theme_void() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  labs(caption = "Source: QGIS")

```
  
  
  
  
## Azimuthal Equidistant projection

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true

temp <- magick::image_read("day2assets/un.png")

magick::image_ggplot(temp) +
  theme_void() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  labs(caption = "Source: QGIS/UN")

```
  
  
  
  
## Mollweide Equal Area Cylindrical projection

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true

temp <- magick::image_read("day2assets/mollweide.png")

magick::image_ggplot(temp) +
  theme_void() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  labs(caption = "Source: QGIS")

```


  
  

## Three families of projections

- The [QGIS website](https://docs.qgis.org/3.34/en/docs/gentle_gis_introduction/coordinate_reference_systems.html) has a great explanation of the three families of projections
  - Cylindrical
  - Conical
  - Planar
  
  
  
  
## Three families of projections

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true

temp <- magick::image_read("day2assets/projections.png")

magick::image_ggplot(temp) +
  theme_void() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  labs(caption = "Source: QGIS")

```








## Coordinate reference systems

- Coordinate reference systems (CRS) are a way to define how coordinates are represented
  - This includes the projection, but also other things
  
- The most popular is probably WGS 84 (EPSG:4326), which is a geographic CRS
  - This is latitude/longitude
- One degree of lat/lon:
  - 60 minutes
- One minute:
  - 60 seconds
  
. . .
  
- Geographic here means it is the location on the earth's surface
  - This is different from a projected CRS, which is more about how to draw the earth on a flat surface
  
  
  
  
## Geographic vs. projected

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true

temp <- magick::image_read("day2assets/gcspcs.png")

magick::image_ggplot(temp) +
  theme_void() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  labs(caption = "Source: ESRI")

```







## A common CRS: Universal Transverse Mercator (UTM)

- Universal Transverse Mercator (UTM) is a projected CRS
  - It divides the world into 60 zones
  - Each zone is 6° wide
  - The equator is the origin of each zone
  - The equator is at 0 m







## Universal Transverse Mercator (UTM)

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true

temp <- magick::image_read("day2assets/utm.png")

magick::image_ggplot(temp) +
  theme_void() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  labs(caption = "Source: QGIS")

```







## A common CRS: Universal Transverse Mercator (UTM)

- UTM defines X values ("longitude") FROM THE MIDDLE of each zone
  - This middle line is called the central meridian

- UTM defines Y values ("latitude") from the equater

- There are some other details:
  - UTM values are never negative, so we offset values
    - This is called a "false easting" and "false northing"
    - Details aren't super important

- Note: it ignores altitude. It assumes a perfect ellipsoid






## "Transverse mercator" projection per zone (N and S)

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true

temp <- magick::image_read("day2assets/utmnew.png")

magick::image_ggplot(temp) +
  theme_void() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  labs(caption = "Source: Wikipedia")

```







## Projections with `sf`

```{r}
#| echo: true
#| include: true
#| fig-align: center
#| crop: true
#| fig-width: 4

admin2 <- read_sf("day2files/mw2.shp")

# Geographic CRS: WGS 84 - lat/lon
crs(admin2)

```







## What is the appropriate zone for Malawi?

- Go to Google
  - Search "UTM CRS Malawi"

- What did you find?

. . .

- UTM zone 36S
- With the `sf` package, we want to find the "EPSG" code to project
  - 20936




## What is the appropriate zone for Malawi?
  
```{r}
#| echo: true
#| include: true
#| fig-align: center
#| crop: true
#| fig-width: 4

admin2proj <- st_transform(admin2, 20936)

# It has changed! Now it's projected
crs(admin2proj)

```




## They look quite similar!

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true

g1 <- ggplot(admin2) +
  geom_sf(fill = "white", color = kdisgreen) +
  theme_bw() +
  labs(subtitle = "A. Geographic CRS") +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
g2 <- ggplot(admin2proj) +
  geom_sf(fill = "white", color = kdisgreen) +
  theme_bw() +
  labs(subtitle = "B. Projected CRS") +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  coord_sf(crs = st_crs(20936))

plot_grid(g1, g2) +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))

```




## They look quite similar! Different coordinates

```{r}
#| echo: true
#| evaluate: false
#| fig-align: center
#| crop: true

g1 <- ggplot(admin2) +
  geom_sf(fill = "white", color = kdisgreen) +
  theme_bw() +
  labs(subtitle = "A. Geographic CRS") +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
g2 <- ggplot(admin2proj) +
  geom_sf(fill = "white", color = kdisgreen) +
  theme_bw() +
  labs(subtitle = "B. Projected CRS") +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  coord_sf(crs = st_crs(20936))

```




## Malawi is small. What about something larger?

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true

temp <- read_sf("day2files/state.shp")

g1 <- ggplot(temp) +
  geom_sf(fill = "white", color = kdisgreen) +
  theme_bw() +
  labs(subtitle = "A. Geographic CRS") +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
g2 <- ggplot(st_transform(temp, 24344)) +
  geom_sf(fill = "white", color = kdisgreen) +
  theme_bw() +
  labs(subtitle = "B. Projected CRS") +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  coord_sf(crs = st_crs(24344))

plot_grid(g1, g2) +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))

```






## Now it's your turn!

- Use the Indian roads shapefile (`indiaprimaryroads.shp`)

- Do the following: 
  - Find the CRS of the shapefile
  - Transform the shapefile to UTM zone 44N (EPSG: 24344)
  - Graph both side by side using `cowplot`






## The solution

```{r}
#| echo: true
#| include: true
#| fig-align: center
#| crop: true

roads <- read_sf("day2files/indiaprimaryroads.shp")
crs(roads)

roadsproj <- st_transform(roads, 24344)
crs(roadsproj)
```






## The solution

```{r}
#| echo: true
#| include: true
#| eval: false
#| fig-align: center
#| crop: true

g1 <- ggplot(roads) +
  geom_sf(fill = "white", color = kdisgreen) +
  theme_bw() +
  labs(subtitle = "A. Geographic CRS")
g2 <- ggplot(roadsproj) +
  geom_sf(fill = "white", color = kdisgreen) +
  theme_bw() +
  labs(subtitle = "B. Projected CRS") +
  coord_sf(crs = st_crs(24344))

plot_grid(g1, g2)
```






## The solution

```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true

g1 <- ggplot(roads) +
  geom_sf(fill = "white", color = kdisgreen) +
  theme_bw() +
  labs(subtitle = "A. Geographic CRS") +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
g2 <- ggplot(roadsproj) +
  geom_sf(fill = "white", color = kdisgreen) +
  theme_bw() +
  labs(subtitle = "B. Projected CRS") +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) +
  coord_sf(crs = st_crs(24344))

plot_grid(g1, g2) +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
```






## More practice

- I'd like you to find a shapefile for a country of your choice
  - Ths isn't always easy
  - I always use Google to find one
  - One place you can often find something on humdata.org (almost always shows up in the search!)
  
- Do the following:
  - Find the CRS of the shapefile
  - Transform the shapefile to the appropriate UTM zone for the country
    - Note that many countries have multiple UTM zones! You can just choose one
  - Plot them side by side using `cowplot`


  
  
  
## Returning to the files

- Shapefiles are made up of _at least_ four files:
  - `.shp` - the shape itself
    - The geometry
  - `.shx` - the index
    - The "index". You can actual recover the .shx file from the .shp file
  - `.dbf` - the attributes
    - The attributes for each features. Could be names, population values, etc.
  - `.prj` - the projection
    - The projection information, which we just discussed

- There are often more files, but these are the main ones
  - You **must** have the first three. The fourth is optional, but common.








## Goal

- By the end of the day, we want to be able to:
  - Use geospatial data to estimate a sub-area model
  - We won't actually do that today, we'll do that tomorrow
  - Today focus is getting ALL of the data we need




## Rasters

- We've discussed shapefiles
  -  Now let's talk about rasters!<br><br>
  
- Rasters are a different type of geospatial data
  - They are made up of a grid of cells
  - Each cell has a value






## Example raster grid - how much info do we need?



```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true
# create example grid
main <- ggplot() +
  geom_hline(yintercept = 1:10, color = "black") +
  geom_vline(xintercept = 1:10, color = "black") +
  theme_bw() +
  labs(x = "X", y = "Y") +
  scale_x_continuous(breaks = 1:10, minor_breaks = NULL) +
  scale_y_continuous(breaks = 1:10, minor_breaks = NULL) + 
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))

gridexample <- ggdraw() +
  draw_plot(
    {
      main +
        coord_sf(
          xlim = c(0.99, 10.01),
          ylim = c(0.99, 10.01),
          expand = FALSE) + 
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
    }
)
gridexample + 
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
```




- Here's a grid.
  - How many points do we need?






## Example raster grid - how much info do we need?



```{r}
#| echo: false
#| include: true
#| crop: true
#| fig-align: center


gridexample + 
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
```




- Need to know location of one grid cell...
  - And the size of each grid!






## How much info do we need?

- In other words, we do not need a point for every raster cell<br><br>

- We just need to know:
  - The location of one cell
  - The size of each cell
    - This is called the `resolution` of the raster<br><br>
    
- Example:
  - I know the first grid cell in bottom left is at (0, 0)
  - I know each grid cell is 1 meter by 1 meter (the resolution)
  - Then I know the exact location of every single grid cell






## Population in Cotonou, Benin



```{r}
#| echo: false
#| include: true
#| crop: true
#| fig-align: center

library(tidyterra)

tif <- rast("day2files/beninpop.tif")

ggplot() +
  geom_spatraster(data = tif, ) + 
  scale_fill_distiller("Population\ncount", palette = "Spectral", na.value = "white") +
  theme_bw() +
  labs(subtitle = "Population in Cotonou, Benin") + 
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))

```



- What are the white values?






## Population in Cotonou, Benin

- Here's the information for this raster
  - What's the resolution? What are the units?




```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true

tif

```








## Rasters

- Rasters are defined by the grid layout and the resolution
  - Grid cells are sometimes called pixels (just like images, which are often rasters!)<br><br>

- There are many different file types for rasters
  - `.tif` or `.tiff` (one of the most common)
  - `.nc` (NetCDF, common for very large raster data)
  - Image files, e.g. `png`, `jpg`, etc.<br><br>






## Reading rasters in R

- Reading rasters is also quite easy!
  - Going to use the `terra` package for it
    - Note: can use `terra` for shapefiles, too
  - `day2files/beninpop.tif` is a raster of population counts in Benin



```{r}
#| echo: true
#| include: true
#| fig-align: center
#| crop: true
library(terra)

# this is the raster for Cotonou, Benin
cotonou <- rast("day2files/beninpop.tif")
cotonou
```









## Plotting rasters

::: columns
::: {.column width="45%"}

- Plotting rasters only with `terra` is a bit of a pain
  - Can't use `ggplot`
  - So, I load another package that lets me use `ggplot` with rasters
    - `tidyterra`



```{r}
#| echo: true
#| eval: false
#| fig-align: center
#| crop: true
library(tidyterra)

ggplot() +
  geom_spatraster(data = cotonou) + 
  theme_bw() +
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
```



:::

::: {.column width="55%"}



```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true
library(tidyterra)

ggplot() +
  geom_spatraster(data = cotonou) + 
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
```



:::
:::







## Making it nicer

::: columns
::: {.column width="45%"}



```{r}
#| echo: true
#| eval: false
#| fig-align: center
#| crop: true
library(tidyterra)

ggplot() +
  geom_spatraster(data = cotonou) + 
  # distiller is for continuous values
  # but we can use palettes!
  # I like spectral a lot
  scale_fill_distiller("Population\ncount", 
    palette = "Spectral", na.value = "white") +
  theme_bw() +
  labs(subtitle = "Population in Cotonou, Benin") + 
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
```



:::

::: {.column width="55%"}



```{r}
#| echo: false
#| include: true
#| fig-align: center
#| crop: true
library(tidyterra)

ggplot() +
  geom_spatraster(data = cotonou) + 
  scale_fill_distiller("Population\ncount", palette = "Spectral", na.value = "white") +
  theme_bw() +
  labs(subtitle = "Population in Cotonou, Benin") + 
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))

```



:::
:::







## Extracting raster data to shapefiles

- Let's go back to our use case:
  - We want to estimate a sub-area model at the EA level in Malawi
  - This means we need to extract raster data to the EA level
  - We can do this with `terra`, `sf`, and `exactextractr`
    - `terra` has its own method, but i find `exactextractr` to be MUCH faster<br><br>
    
- Let's start by looking at the raster I've uploaded to the `day2data`: `mwpop.tif`







## Give it a try

::: columns
::: {.column width="50%"}

- Try to load it into R using terra, then plot it with tidyterra and ggplot



```{r}
#| echo: true
#| eval: false
#| fig-align: center
#| code-fold: show
#| crop: true

tif <- rast("day2files/mwpop.tif")

ggplot() +
  geom_spatraster(data = tif) + 
  scale_fill_distiller("Population\ncount", 
    palette = "Spectral", na.value = "white") +
  theme_bw() +
  labs(subtitle = "Population in Northern Malawi") + 
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
```



:::

::: {.column width="50%"}



```{r}
#| echo: false
#| eval: true
#| fig-align: center
#| code-fold: show
#| crop: true

tif <- rast("day2files/mwpop.tif")

ggplot() +
  geom_spatraster(data = tif) + 
  scale_fill_distiller("Population\ncount", 
    palette = "Spectral", na.value = "white") +
  theme_bw() +
  labs(subtitle = "Population in Northern Malawi") + 
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
```



:::
:::







## Give it a try

::: columns
::: {.column width="50%"}

- I actually don't like that map! It's too hard to see because of all the low values.
- So let's take logs, instead!
  - Note that all the zeros become missing (can't log zero)



```{r}
#| echo: true
#| eval: false
#| fig-align: center
#| code-fold: show
#| crop: true

tif <- rast("day2files/mwpop.tif")

ggplot() +
  geom_spatraster(data = log(tif)) + 
  scale_fill_distiller("Population\ncount (log)", 
    palette = "Spectral", na.value = "white") +
  theme_bw() +
  labs(subtitle = "Population in Northern Malawi") + 
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
```



:::

::: {.column width="50%"}



```{r}
#| echo: false
#| eval: true
#| fig-align: center
#| code-fold: show
#| crop: true

tif <- rast("day2files/mwpop.tif")

ggplot() +
  geom_spatraster(data = log(tif)) + 
  scale_fill_distiller("Population\ncount (log)", 
    palette = "Spectral", na.value = "white") +
  theme_bw() +
  labs(subtitle = "Population in Northern Malawi") + 
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
```



:::
:::







## We want to extract the .tif values to the .shp



```{r}
#| echo: false
#| eval: true
#| fig-align: center
#| crop: true

tif <- rast("day2files/mwpop.tif")
adm4 <- read_sf("day2files/mw4.shp")

g1 <- ggplot() +
  geom_spatraster(data = tif) + 
  scale_fill_distiller("Population\ncount (log)", 
    palette = "Spectral", na.value = "white") +
  theme_bw() +
  labs(subtitle = "Population in Northern Malawi") + 
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
g2 <- ggplot() +
  geom_sf(data = adm4, color = "black", fill = "transparent", lwd = 0.1) + 
  theme_bw() +
  labs(subtitle = "EAs (admin4) Northern Malawi") + 
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))

plot_grid(g1, NA, g2, ncol = 3, rel_widths = c(1, 0.05, 1)) + 
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))
```









## Let's do it with `exactextractr`



```{r}
#| echo: true
#| eval: false
#| include: true
#| fig-align: center
#| crop: true
library(exactextractr)

tif <- rast("day2files/mwpop.tif")
adm4 <- read_sf("day2files/mw4.shp")
# make sure they are in the same CRS! (they already are, but just in case)
# st_transform is for the sf object
adm4 <- st_transform(adm4, crs = crs(tif))

# extract the raster values to the shapefile
# we are going to SUM, and add the EA_CODE from the shapefile to the result
extracted <- exact_extract(tif, adm4, fun = "sum", append_cols = "EA_CODE")
```

```{r}
#| echo: false
#| eval: true
#| include: false
#| fig-align: center
#| crop: true
library(exactextractr)

tif <- rast("day2files/mwpop.tif")
adm4 <- read_sf("day2files/mw4.shp")
# make sure they are in the same CRS! (they already are, but just in case)
# st_transform is for the sf object
adm4 <- st_transform(adm4, crs = crs(tif))

# extract the raster values to the shapefile
# we are going to SUM, and add the EA_CODE from the shapefile to the result
extracted <- exact_extract(tif, adm4, fun = "sum", append_cols = "EA_CODE")
# save it!
write_csv(extracted |> rename(pop = sum), "day2files/mwpopEAs.csv")
```

```{r}
#| echo: true
#| eval: true
#| include: true
#| fig-align: center
#| crop: true

head(extracted)
```









## Now we can join the extracted data to the shapefile


::: columns
::: {.column width="45%"}




```{r}
#| echo: true
#| eval: false
#| include: true
#| fig-align: center
#| crop: true

# join
adm4 <- adm4 |>
  left_join(extracted, by = "EA_CODE")

# plot it!
ggplot() +
  geom_sf(data = adm4, aes(fill = sum), 
    color = "black", lwd = 0.01) +
  scale_fill_distiller("Population\ncount", 
    palette = "Spectral", na.value = "white") +
  theme_bw() +
  labs(subtitle = "Population in EAs") + 
  theme(plot.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb")) + 
  theme(legend.background = element_rect(fill = "#f0f1eb", color = "#f0f1eb"))

```



:::

::: {.column width="55%"}

![](day2assets/mwpopEAs.png){fig-align="center"}

:::
:::







## Now it's your turn

- Here's your task:
  - Search for "worldpop population counts"
    - Should be the first result (link: [https://hub.worldpop.org/project/categories?id=3](https://hub.worldpop.org/project/categories?id=3))
  - Scroll down the page, click on "unconstrained individual countries 2000-2020 UN adjusted (1km resolution)

![](day2assets/worldpoppage1.png){fig-align="center"}






## Now it's your turn

- Here's your task:
  - Search for "worldpop population counts"
    - Should be the first result (link: [https://hub.worldpop.org/project/categories?id=3](https://hub.worldpop.org/project/categories?id=3))
  - Scroll down the page, click on "unconstrained individual countries 2000-2020 UN adjusted (1km resolution)
  - Then, search for a country (maybe yours?)

![](day2assets/worldpoppage2.png){fig-align="center"}





## Now it's your turn

- Here's your task:
  - Search for "worldpop population counts"
    - Should be the first result (link: [https://hub.worldpop.org/project/categories?id=3](https://hub.worldpop.org/project/categories?id=3))
  - Scroll down the page, click on "unconstrained individual countries 2000-2020 UN adjusted (1km resolution)
  - Then, search for a country (maybe yours?)
  - Click on "Data & Resources" for 2020
  - Scroll down to the bottom of the page and download the .tif





## Now it's your turn

- Load the .tif into R using `terra`
- Plot the raster using `tidyterra` and `ggplot`
  - Make it look nice!





## Let's keep going!

- Now you need to find a shapefile for the same country
- This will be a bit less straightforward
  - Search for "shapefile COUNTRY humdata"
  - You should find a link to the Humanitarian Data Exchange
  - Click on it and see if it has shapefiles for your country of choice
  - If so, download a shapefile (it can be at a higher admin level)
    - If not, raise your hand and I'll come help you find a shapefile
  - Load it into R and plot it!





## One last thing

- You have the population tif and the shapefile
- Extract the population data (using sum, don't forget!) to the shapefile
  - Use `append_cols` and make sure you choose the correct identifier!
- Join the data to the shapefile
- Plot the shapefile with the population data
  - Make it look nice!





## What can you do with that data?

- Now you have a shapefile with population data
- You can save it as a `.csv` and use it in your analysis!
  - We'll get to this point eventually.
  - We will also discuss adding the survey data and then estimating a sub-area model





## Creating a grid

- Yesterday, we used a grid in Korea
  - kgrid.shp

- By now, you can probably see that a grid is very similar to a raster!





## Load the shapefile

- Let's load kshape.shp



```{r}
#| echo: true
#| eval: true
#| include: true
#| fig-align: center
#| crop: true

kshape <- vect("day2files/kshape.shp")
kgrid <- rast(kshape, res = 5000)
kgrid <- as.polygons(kgrid)
kgrid$id <- 1:nrow(kgrid)
```







## The grid



```{r}
#| echo: false
#| eval: true
#| include: true
#| fig-align: center
#| crop: true

ggplot() +
  geom_spatvector(data = kgrid) +
  theme_bw()
```







## Not quite done

- We aren't quite done. What do we want to do now?

. . .



```{r}
#| echo: true
#| eval: true
#| include: true
#| fig-align: center
#| crop: true

intersection <- intersect(kshape, kgrid)
kgrid <- kgrid |>
  filter(id %in% intersection$id)
```







## Not quite done



```{r}
#| echo: false
#| eval: true
#| include: true
#| fig-align: center
#| crop: true

ggplot() + geom_spatvector(data = kgrid)
```









